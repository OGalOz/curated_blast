<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>SWISS::BaseClass</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:operations@isb-sib.ch" />
</head>

<body style="background-color: white">


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#functions">Functions</a></li>
	<li><a href="#a_skeletal_derived_class">A skeletal derived class</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>SWISS::BaseClass</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This class is designed to impliment many of the properties that you
expect in inheritance.  All the housekeeping functions are defined
in this module.  See the notes on use for a description of how to
make use of it.</p>
<p>
</p>
<hr />
<h1><a name="functions">Functions</a></h1>
<dl>
<dt><strong><a name="new" class="item">new</a></strong></dt>

<dd>
<p>Returns a new SWISS::BaseClass object.</p>
</dd>
<dt><strong><a name="rebless" class="item">rebless</a></strong></dt>

<dd>
<p>Converts a base class into your class!  Call as $self-&gt;<a href="#rebless"><code>rebless($class)</code></a> where
$self is a base class object.  It returns $self, reblessed, with the correct
member variables.</p>
</dd>
<dt><strong><a name="initialize" class="item">initialize</a></strong></dt>

<dd>
<p>Override this in each derived class to provide class specific initialization.
For example, initialize may put arrays into member variables that need them.
You must provide an initialize function.</p>
</dd>
<dt><strong><a name="reformat" class="item">reformat</a></strong></dt>

<dd>
<p>Some line objects are implementing &quot;lazy writing&quot;. This means that on writing an entry, they are only reformatted if they have been modified. The method reformat forces an object to be reformatted even if its content has not been modified. This may be useful e.g. to make sure the current formatting rules are applied.</p>
</dd>
<dt><strong><a name="setevidencetags_array" class="item">setEvidenceTags @array</a></strong></dt>

<dd>
<p>Sets the evidence tags of the object to the list passed in @array.</p>
</dd>
<dt><strong><a name="addevidencetag_string" class="item">addEvidenceTag string</a></strong></dt>

<dd>
<p>Adds the evidence tag to the object.</p>
</dd>
<dt><strong><a name="deleteevidencetag_string" class="item">deleteEvidenceTag string</a></strong></dt>

<dd>
<p>Deletes the evidence tag from the object.</p>
</dd>
<dt><strong><a name="hasevidencetag_string" class="item">hasEvidenceTag string</a></strong></dt>

<dd>
<p>returns true if the object has the evidence tag.</p>
</dd>
<dt><strong><a name="getevidencetags" class="item">getEvidenceTags</a></strong></dt>

<dd>
<p>returns the array of evidence tags of the object</p>
</dd>
<dt><strong><a name="check4clashes" class="item">Check4Clashes</a></strong></dt>

<dd>
<p>This function checks your classes member variable list for clashes with any class
that it inherits from (any class that can(_containsFields) returns true on!).  If it
detects that in any base class that any data members have been already defined,
it dies with a listing of the variables already used.</p>
<p>It stops searching a root of an inheritance hierachy when it can find no baseclasses that
support _containsFields.  It will find all clashes in an entire inheritance tree.</p>
<p>So in the inheritance hierachy of</p>
<pre>
 SWISS::BaseClass -&gt; A -&gt; B -\
                             &gt; E
 SWISS::BaseClass -&gt; C -&gt; D -/</pre>
<p>where E is the most derived class, if E contains names that clash with A members
and names that clash with B members, both the A and B member clashes will be reported.</p>
<p>If there were clashes with B and C, say, then again, all of the clashes would be reported.</p>
</dd>
<dt><strong><a name="containsfields" class="item">_containsFields</a></strong></dt>

<dd>
<p>This function is responsible for comparing a classes fields with the set in the
calling package.  This implimentation will work for cases where all of the
classes that contribute fields are derived from SWISS::BaseClass.  You may wish to
make your own class fit this interface, so what follows is an interface API.</p>
<p>_containsFields assumes that the first argument is the package that it is being called in.
The following arguments are taken to be a list of fields which to check are not found
in members of the current package.</p>
<p>It should return either <code>undef</code> or a reference to an array of name clashes in the format
<code>package::variable</code>.  It should call it's self for each parental class that supports this
function.</p>
<p>So it would look something like
  _containsFields {
    my $class = shift;
    my @toCheck = @_;</p>
<pre>
    foreach @toCheck {
      check that they are not in me.  If they are, add them to the list of clashes to return.
    }</pre>
<pre>
    add all base class clashes to your list of clashes</pre>
<pre>
    if there were name clashes return a reference to them</pre>
<pre>
    otherwise return undef
  }</pre>
</dd>
<dt><strong><a name="equal" class="item">equal</a></strong></dt>

<dd>
<p>If two objects are equal, it returns true.</p>
<p>Warning: This funktion compares two objects using a simple dump in Perl format, see Data::Dumper module. The comparison also takes private variables into account. Therefore: If the method 'equal' returns true, the objects are guaranteed to be equal, but it might return false although the two objects are equal in they public attributes.</p>
</dd>
<dt><strong><a name="copy" class="item">copy</a></strong></dt>

<dd>
<p>Returns a &quot;deep copy&quot; of the object.</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="a_skeletal_derived_class">A skeletal derived class</a></h1>
<pre>
 package myDerived;</pre>
<pre>
 use vars qw ( @ISA %fields );</pre>
<pre>
 BEGIN {
    @ISA = ('SWISS::BaseClass');</pre>
<pre>
    %fields = (
               'i' =&gt; 1,
               'hash' =&gt; undef
               );

</pre>
<pre>
    myDerived-&gt;check4Clashes();
 }

</pre>
<pre>
 sub new {
    print &quot;myDerived::new(@_)\n&quot;;
    my $class = shift;
    my $self = new SWISS::BaseClass;
    
    $self-&gt;rebless ($class);
    
    return $self;
 }

</pre>
<pre>
 sub initialize {
    my $self = shift;
    $self-&gt;{'hash'} = {};
 }

</pre>
<p>A class derived from myDerived would just substitute the name myDerived
for SWISS::BaseClass.  Hey presto - all sorted!</p>

</body>

</html>
